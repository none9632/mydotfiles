set icons true
set hidden true
set drawbox true
set preview true
set info size
set dircounts on
set timefmt " Jan _2 2006 15:04:05"
set tabstop 4
set period 1
set promptfmt ""
set errorfmt "\033[38;5;1m error: \033[0m%s"
set shell 'sh'
set shellopts '-eu'
set ifs "\n"
set scrolloff 10
set previewer ~/.config/lf/scripts/lf_previewer
set cleaner ~/.config/lf/scripts/lf_cleaner

%{{
    touch /tmp/lfundo_$id
    lf_update . $id
}}

cmd recol &{{
    # w=$(tput cols)
    # if [ $w -le 100 ]; then
    #     lf -remote "send $id set ratios 2:3"
    # else
    #     lf -remote "send $id set ratios 1:2:3"
    # fi
    lf -remote "send $id set ratios 1:2:3"
}}

cmd my_open %{{
    case $(file --mime-type $f -b) in
        text/* | inode/x-empty)
            lf -remote "send $id push e" ;;
        inode/directory)
            fix_f="$(echo $f | sed 's/\ /\\\ /g')"
            lf -remote "send $id my_cd $fix_f" ;;
        inode/symlink)
            if [ -d "$f" ]
            then
                fix_f="$(echo $f | sed 's/\ /\\\ /g')"
                lf -remote "send $id my_cd $fix_f"
            else
                lf -remote "send $id push e"
            fi
            ;;
        application/pdf | image/vnd.djvu)
            evince $f ;;
        font/sfnt)
            font-manager $f ;;
        *)
            for f in $fx; do setsid $OPENER $f > /dev/null 2> /dev/null & done ;;
    esac
}}

cmd my_cd &{{
    FILE="/tmp/lfundo_$id"
    lf_prepare_file $FILE

    sed -i "1s|^|$PWD\n|" $FILE
    sed -i "1s|^|cd\n|" $FILE

    fix_f="$(echo $1 | sed 's/\ /\\\ /g')"
    eval zoxide add $fix_f
    lf -remote "send $id cd $fix_f"
    lf_update $1 $id
}}

cmd my_updir %{{
    FILE="/tmp/lfundo_$id"
    lf_prepare_file $FILE

    sed -i "1s|^|$PWD\n|" $FILE
    sed -i "1s|^|cd\n|" $FILE

    lf -remote "send $id updir"
    lf_update "$(dirname $PWD)" $id
}}

cmd mkdir &{{
    FILE="/tmp/lfundo_$id"
    lf_prepare_file $FILE

    dir_name=$(input "Dir name:")
    while [ -e $dir_name ] && [ "$dir_name" != "" ]
    do
        errormsg "directory exists"
        dir_name=$(input "Dir name:")
    done

    if [ "$dir_name" != "" ]
    then
        mkdir $dir_name
        sed -i "1s|^|$(pwd)/$dir_name\n|" $FILE
        sed -i "1s|^|del\n|" $FILE

        lf -remote "send $id load"
    fi
}}

cmd mkfile &{{
    FILE="/tmp/lfundo_$id"
    lf_prepare_file $FILE

    file_name=$(input "File name:")
    while [ -e $file_name ] && [ "$file_name" != "" ]
    do
        errormsg "file exists"
        file_name=$(input "File name:")
    done

    if [ "$file_name" != "" ]
    then
        touch $file_name
        sed -i "1s|^|$(pwd)/$file_name\n|" $FILE
        sed -i "1s|^|del\n|" $FILE

        lf -remote "send $id load"
    fi
}}

cmd my_rename &{{
    FILE="/tmp/lfundo_$id"
    lf_prepare_file $FILE

    echo "${f##*/}" | xclip -selection clipboard

    new_name=$(input "New name:")
    while [ -e $new_name ] && [ "$new_name" != "" ]
    do
        errormsg "file exists"
        new_name=$(input "New name:")
    done

    if [ "$new_name" != "" ]
    then
        mv $f $new_name
        sed -i "1s|^|$f\n|" $FILE
        sed -i "1s|^|$(dirname $f)/$new_name\n|" $FILE
        sed -i "1s|^|name_restore\n|" $FILE

        lf -remote "send $id load"
    fi
}}

cmd my_copy &{{
    echo -e "$fx" > /tmp/lfcp
    sed -i "1s|^|cp\n|" /tmp/lfcp

    lf -remote "send $id copy"
    lf -remote "send $id load"
}}

cmd my_cut &{{
    echo -e "$fx" > /tmp/lfcp
    sed -i "1s|^|mv\n|" /tmp/lfcp

    lf -remote "send $id cut"
    lf -remote "send $id load"
}}

cmd my_paste &{{
    FILE="/tmp/lfundo_$id"
    lf_prepare_file $FILE

    command=$(head -n 1 /tmp/lfcp)
    sed -i '1d' /tmp/lfcp

    while read line;
    do
        name=$(basename $line)
        while [ -e ./$name ]
        do
            name=$name"_"
        done

        if [ "$command" = "cp" ]
        then
            cp -r $line ./$name
        else
            mv $line ./$name
            sed -i "1s|^|$line\n|" $FILE
        fi
        sed -i "1s|^|$(pwd)/$name\n|" $FILE
    done < /tmp/lfcp

    if [ "$command" = "cp" ]
    then
        sed -i "1s|^|del\n|" $FILE
    else
        sed -i "1s|^|mv\n|" $FILE
    fi

    > /tmp/lfcp
    lf -remote "send $id clear"
    lf -remote "send $id reload"
}}

cmd undo &{{
    FILE="/tmp/lfundo_$id"
    command="$(head -n 1 $FILE)"
    sed -i '1d' $FILE

    if [ "$command" = "trash_restore" ]
    then
        while read line;
        do
            [[ -z "$line" ]] && break
            gio trash --restore $line
            sed -i '1d' $FILE
        done < $FILE
    elif [ "$command" = "name_restore" ]
    then
        mv $(head -n 2 $FILE)
        sed -i '2d' $FILE
    elif [ "$command" = "del" ]
    then
        while read line;
        do
            [[ -z "$line" ]] && break
            rm -rf $(head -n 1 $FILE)
            sed -i '1d' $FILE
        done < $FILE
    elif [ "$command" = "mv" ]
    then
        while read line;
        do
            [[ -z "$line" ]] && break
            mv $(head -n 2 $FILE)
            sed -i '2d' $FILE
        done < $FILE
    elif [ "$command" = "cd" ]
    then
        lf -remote "send $id cd $(head -n 1 $FILE)"
        sed -i '1d' $FILE
    fi

    sed -i '1d' $FILE
    lf -remote "send $id load"
}}

cmd chmod &{{
    for file in $fx
    do
        chmod $1 $file
    done
    lf -remote "send $id reload"
}}

cmd trash &{{
    FILE="/tmp/lfundo_$id"
    lf_prepare_file $FILE

    for filename in $fx
    do
        gio trash $filename
        filename="${filename##*/}"
        sed -i "1s|^|trash:///$filename\n|" $FILE
    done
    sed -i "1s|^|trash_restore\n|" $FILE

    lf -remote "send $id load"
}}

cmd trash_restore &{{
    for file in $fx
    do
        gio trash --restore trash:///$(basename $file)
    done
    lf -remote "send $id reload"
}}

cmd trash_empty &{{
    gio trash --empty
    lf -remote "send $id reload"
}}

cmd fzf_jump ${{
    path="$(find -L . \( -path '*/\*' -o -fstype 'dev' -o -fstype 'proc' \) -prune \
        -o -print 2> /dev/null | sed 1d | cut -b3- | fzf --reverse +m -e --preview='ls -1A {}')"
    if [ "$path" != "" ]
    then
        if [ -d "$path" ]
        then
            lf -remote "send $id my_cd $path"
        else
            lf -remote "send $id select $path"
        fi
    fi
}}

cmd fzf_jump_prev &{{
    tmp_file=$(mktemp)
    awesome-client "create_lf_terminal(\"export _ZO_FZF_OPTS=\\\"--height 100%\
                                                                 --reverse\
                                                                 --no-sort\
                                                                 --preview-window right:35%\
                                                                 --preview=\\\\\\\"ls -1A {2..}\\\\\\\"\\\";\
                                         path=\$(zoxide query -i);\
                                         if [ \\\"\$path\\\" != \\\"\\\" ]; then\
                                             echo -n \$path > $tmp_file;\
                                         else\
                                             echo -n cancel > $tmp_file;\
                                         fi\", 1100, 600)"
    while ! [ -s $tmp_file ]; do sleep 0.1; done
    path="$(cat $tmp_file)"
    [ "$path" != "cancel" ] && lf -remote "send $id my_cd $path"
}}

cmd my_search %{{
    path=$(filesearch $PWD)
    if [ -d $path ]
    then
        lf -remote "send $id my_cd $path"
    else
        lf -remote "send $id select $path"
    fi
}}

cmd goto_config %{{
    path=$(filesearch ~/.config)
    if [ -d $path ]
    then
        lf -remote "send $id my_cd $path"
    else
        lf -remote "send $id select $path"
    fi
}}

cmd git_clone &{{
    link=$(longinput "Link:")
    if [ "$link" != "" ]
    then
        awesome-client "create_lf_terminal(\"cd $PWD;\
                                             git clone $link;\
                                             printf \\\"%s \\\" \\\"Press enter to continue\\\";\
                                             read ans\", 900, 210)"
    fi
}}

cmd chng_layout %{{
    xdotool key Mode_switch
    lf -remote "send $id push $1"
}}

cmd my_quit ${{
    rm /tmp/lfundo_$id
    lf -remote "send $id quit"
}}

cmd quit_for_emacs ${{
    rm /tmp/lfundo_$id
    if [ "$f" = "" ]
    then
        echo -n "cancel" > ~/.cache/emacs/path
    else
        echo -n $f > ~/.cache/emacs/path
    fi
    lf -remote "send $id quit"
}}

# Remove some defaults
map m
map c
map d
map t
map y
map p
map f
map x

# basic
map q my_quit
map l my_open
map h my_updir
map r recol
map / my_search

# select/unselect everything
map a glob-select *
map <esc> :clear; unselect

# see hidden files
map . :set hidden!

# movement
map gh my_cd ~
map gc goto_config
map gp my_cd ~/Pictures
map gd my_cd ~/Documents
map gD my_cd ~/Downloads
map g/ my_cd /
map gt my_cd ~/.local/share/Trash/files
map ge my_cd /etc
map gm my_cd /run/media
map gM my_cd /mnt
map gu my_cd /usr
map gv my_cd /var

# chmod
map +x chmod +x
map +w chmod +w
map +r chmod +r
map -x chmod -x
map -w chmod -w
map -r chmod -r

# file operations
map md mkdir
map mf mkfile
map cw my_rename
map y my_copy
map p my_paste
map s my_cut
map d trash
map D delete
map u undo
map tr trash_restore
map te trash_empty
map i git_clone

# execute current file (must be executable)
map x !$f
map X $$f

# find files
map fd fzf_jump_prev
map cd fzf_jump
map fg :cd /; fzf_jump

# Automatic switchover of the Russian layout
map а chng_layout f
map б chng_layout ,
map в chng_layout d
map г chng_layout u
map д chng_layout l
map е chng_layout t
map ё chng_layout `
map ж chng_layout ;
map з chng_layout p
map и chng_layout b
map й chng_layout q
map к chng_layout r
map л chng_layout k
map м chng_layout v
map н chng_layout y
map о chng_layout j
map п chng_layout g
map р chng_layout h
map с chng_layout c
map т chng_layout n
map у chng_layout e
map ф chng_layout a
map х chng_layout x
map ц chng_layout w
map ч chng_layout x
map ш chng_layout i
map щ chng_layout o
map ъ chng_layout ]
map ы chng_layout s
map ь chng_layout m
map э chng_layout '
map ю chng_layout .
map я chng_layout m
